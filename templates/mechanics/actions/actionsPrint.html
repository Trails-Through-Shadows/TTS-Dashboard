{% load static %}
{% load filters %}
{% load i18n %}

<div class="modal" id="modal" aria-hidden="true">
    <div class="modal-overlay" tabindex="-1" data-micromodal-close>
        <div class="modal-container" role="dialog" aria-modal="true" aria-labelledby="modal-title">
            <header class="modal-header border-0" style="flex-direction: row-reverse;">
                <button class="modal-close hvr-grow" aria-label="Close modal">
                    <i class="fa-solid fa-xmark"></i>
                </button>
            </header>

            <main class="modal-body pt-0 pb-0" id="loading" style="max-height: 620px; margin-left: 12.5px;">
                <div id="card" style="scale: 0.7; transform-origin: 0; -webkit-transform-origin-y: top; -webkit-transform-origin-x: left;"></div>
            </main>

            <footer class="modal-footer border-0 justify-content-center">
                <div class="row">
                    <div class="col-12 col-md-4">
                        <a href="#" target="_top" id="actionDownloadPNG" class="btn btn-sm btn-gray-800">
                            <i class="fa-solid fa-file-image"></i>
                            {% trans 'Download as PNG' %}
                        </a>
                    </div>
                    <div class="col-12 col-md-4">
                        <a href="#" target="_top" id="actionDownloadPDF" class="btn btn-sm btn-gray-800">
                            <i class="fa-solid fa-file-pdf"></i>
                            {% trans 'Download as PDF' %}
                        </a>
                    </div>
                    <div class="col-12 col-md-4">
                        <a href="#" target="_top" id="actionDownloadSVG" class="btn btn-sm btn-gray-800">
                            <i class="fa-solid fa-panorama"></i>
                            {% trans 'Download as SVG' %}
                        </a>
                    </div>
                </div>
            </footer>
        </div>
    </div>
</div>

<script id="afterScript" async>
    const csrfToken = document.querySelector('#csrftoken').value;

    Notiflix.Block.circle("#loading", 'Loading...');

    let height = 880;
    let width = 630;

    function convertSVGToPDF(svg, filename) {
        const img = new Image();
        img.onload = function () {
            console.log("Image loaded");

            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({
                orientation: "p",
                unit: "pt",
                format: [width, height]
            });
            
            pdf.svg(svg, {
                x: 0,
                y: 0,
                width: width,
                height: height
            }).then(() => {
                console.log("PDF generated");
                pdf.save(filename);
            });
        };

        const svgData = new XMLSerializer().serializeToString(svg);
        img.src = "data:image/svg+xml;base64," + btoa(svgData);
    }

    function convertSVGToPNG(svg, filename) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");

        const img = new Image();
        img.onload = function () {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            const a = document.createElement("a");
            a.href = canvas.toDataURL("image/png");
            a.download = filename;
            a.click();
        };
        img.src = "data:image/svg+xml;base64," + btoa(svg);
    }

    const actionDownloadPNG = document.getElementById("actionDownloadPNG");
    actionDownloadPNG.addEventListener("click", async function (event) {
        event.preventDefault();

        const svg = document.getElementById("card").firstChild;
        const svgData = new XMLSerializer().serializeToString(svg);
        convertSVGToPNG(svgData, "download.png");
    });

    const actionDownloadPDF = document.getElementById("actionDownloadPDF");
    actionDownloadPDF.addEventListener("click", async function (event) {
        event.preventDefault();

        const svg = document.getElementById("card").firstChild;
        convertSVGToPDF(svg, "download.pdf");
    });
    
    const actionDownloadSVG = document.getElementById("actionDownloadSVG");
    actionDownloadSVG.addEventListener("click", async function (event) {
        event.preventDefault();

        const svg = document.getElementById("card").firstChild;
        const svgData = new XMLSerializer().serializeToString(svg);

        const blob = new Blob([svgData], { type: "image/svg+xml" });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = "download.svg";
        a.click();
    });

    async function generateCard(actionId) {
        // remove previous card
        let card = document.getElementById("card");
        while (card.firstChild) {
            card.removeChild(card.firstChild);
        }

        const response = await fetch('{% url 'apiCardData' actionId=0 %}'.replace('0', actionId), {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            }
        });

        // check if status is 200
        const action = await response.json();
        if (action.status == "BAD_REQUEST" || action.status == "NOT_FOUND") {
            console.log("Error: ", action.message);
            return;
        }

        let gradient = new SVG.Color(action.color).to('#fff');
        let black = '#000';
        let color = gradient.at(0).toHex();
        let lightColor = gradient.at(0.9).toHex();

        let draw = SVG().addTo('#card').size(width, height);

        let border = draw.rect(width, height).radius(20).attr({fill: black});
        let backgroundBorder = draw.rect(width - 5, height - 5).radius(18).attr({fill: color}).move(2.5, 2.5);
        let background = draw.rect(width - 10, height - 10).radius(16).attr({fill: lightColor}).move(5, 5);

        // icon at right left corner
        let source = draw.rect(100, 100).radius(20).attr({fill: black}).move(width - 100, 0);
        let sourceBackground = draw.rect(95, 95).radius(18).attr({fill: lightColor}).move(width - 97.5, 2.5);

        // print action.icon as image to source background
        if (action.icon == null) {
            if (action.source == "ENEMY") {
                action.icon = "{% static 'img/card/feature/hydra-ugly-enemy-legend-svgrepo-com.svg' %}";
            } else {
                action.icon = "{% static 'img/card/feature/question-svgrepo-com.svg' %}";
            }

            let image = draw.image(action.icon).size(90, 90).move(width - 99, 5);
        } else {
            let image = draw.image(action.icon + "?size=90&radius=15").move(width - 95, 5);
        }

        let textWidth = width - 400;
        let currentHeightOffset = 20;
        console.log("init:", currentHeightOffset);

        // title
        let title = draw.text(function (add) {
            let prevLength = 0;
            let split = action.title.split(' ');

            for (let i = 0; i < split.length; i += 1) {
                let char = split[i];
                let newline = false;

                if (add.length() - prevLength > textWidth - 150) {
                    prevLength = add.length();
                    newline = true;
                }

                if (newline) {
                    add.tspan(char).newLine();
                } else {
                    add.tspan(' ' + char);
                }
            }
        });

        title.font({fill: black, size: 50, family: 'Helvetica', weight: 'bold'}).move(20, currentHeightOffset);
        currentHeightOffset += title.bbox().height + 20;
        console.log("after tit:", currentHeightOffset);

        // description
        let description = draw.text(function (add) {
            let prevLength = 0;
            let descSplit = action.description.split(' ');

            for (let i = 0; i < descSplit.length; i += 1) {
                let char = descSplit[i];
                let newline = false;

                if (add.length() - prevLength > textWidth) {
                    prevLength = add.length();
                    newline = true;
                }

                if (newline) {
                    add.tspan(char).newLine();
                } else {
                    add.tspan(' ' + char);
                }
            }
        });

        description.font({fill: black, size: 30, family: 'Helvetica'}).move(20, currentHeightOffset);
        currentHeightOffset += description.bbox().height;
        console.log("after desc:", currentHeightOffset);

        // line after description
        let line = draw.line(20, currentHeightOffset + 20, width - 20, currentHeightOffset + 20).stroke({
            width: 2,
            color: black
        });
        currentHeightOffset += 60;

        function drawEffect(effect, x, y) {
            let iconPath = effect.url.replace(".png", ".svg").replace("/images/", "/images/svgs/");
            console.log("icon path:", iconPath);

            let wordSize = 30;
            let imageWidth = 70;

            if (effect.duration == null) {
                effect.duration = "-";
            }
            if (effect.strength == null) {
                effect.strength = "-";
            }

            let durationText = draw.text(effect.duration).font({fill: black, size: wordSize, family: 'Helvetica'}).move(x, y + 40);
            let image = draw.image(iconPath).size(imageWidth, imageWidth).move(x + durationText.length(), y);
            let strengthText = draw.text(effect.strength).font({fill: black, size: wordSize, family: 'Helvetica'}).move(x + imageWidth + durationText.length(), y + 40);

            console.log("effect width:", durationText.length() + imageWidth + strengthText.length() + 20);
            return 120;
        }

        function drawEffects(effects, y) {
            let count = effects.length;
            if (count === 0) {
                return 0;
            }

            let currentWidthOffset = 20;
            let currentHeightOffset = y;
            currentHeightOffset += 70;

            let effectBorderWidth = 120 * count + 20;
            draw.rect(effectBorderWidth, 90).radius(20).attr({fill: black}).move(currentWidthOffset, currentHeightOffset);
            draw.rect(effectBorderWidth - 5, 85).radius(18).attr({fill: lightColor}).move(currentWidthOffset + 2.5, currentHeightOffset + 2.5);

            currentWidthOffset += 20;
            currentHeightOffset += 10;

            for (let effect of effects) {
                currentWidthOffset += drawEffect(effect.effect, currentWidthOffset, currentHeightOffset);
            }

            return 80;
        }

        function drawIcon(icon, name, value, x, y) {
            let iconPath;

            switch (icon) {
                case "bow":
                    iconPath = "{% static 'img/card/feature/bow-svgrepo-com.svg' %}";
                    break;
                case "tag":
                    iconPath = "{% static 'img/card/feature/tag-svgrepo-com.svg' %}";
                    break;
                case "muscle":
                    iconPath = "{% static 'img/card/feature/muscle-svgrepo-com.svg' %}";
                    break;
                case "arrow":
                    iconPath = "{% static 'img/card/feature/arrow-increase-svgrepo-com.svg' %}";
                    break;
                case "hash":
                    iconPath = "{% static 'img/card/feature/hash-02-svgrepo-com.svg' %}";
                    break;
                case "person":
                    iconPath = "{% static 'img/card/feature/person-svgrepo-com.svg' %}";
                    break;
                case "random":
                    iconPath = "{% static 'img/card/feature/random-1dice-svgrepo-com.svg' %}";
                    break;
                case "target":
                    iconPath = "{% static 'img/card/feature/target-2-svgrepo-com.svg' %}";
                    break;
                default:
                    iconPath = "{% static 'img/card/feature/question-svgrepo-com.svg' %}";
            }

            draw.image(iconPath).move(x, y).size(50, 50);
            let nameText = draw.text(name).font({fill: black, size: 20, family: 'Helvetica'}).move(x + 60, y);

            if (value == "ALL_ENEMIES") {
                value = "All Enemies";
            } else if (value == "ALL_ALLIES") {
                value = "All Allies";
            } else if (value == "SELF") {
                value = "Self";
            } else if (value == "ALL") {
                value = "All";
            } else if (value == "ONE") {
                value = "One";
            }

            let valueText = draw.text(value).font({fill: black, size: 30, family: 'Helvetica'}).move(x + 60, y+20);

            let biggerLength = nameText.length() > valueText.length() ? nameText.length() : valueText.length();
            return 50 + biggerLength + 30;
        }

        // movement
        if (action.movement != null) {
            let currentWidthOffset = 20;
            draw.text("Movement").font({fill: black, size: 40, family: 'Helvetica'}).move(20, currentHeightOffset);
            currentHeightOffset += 60;

            currentWidthOffset += drawIcon("bow", "Range", action.movement.range, currentWidthOffset, currentHeightOffset);
            currentWidthOffset += drawIcon("tag", "Type", action.movement.type, currentWidthOffset, currentHeightOffset);

            currentHeightOffset += drawEffects(action.movement.effects, currentHeightOffset);

            currentHeightOffset += 100;
        }

        // attack
        if (action.attack != null) {
            let currentWidthOffset = 20;
            draw.text("Attack").font({fill: black, size: 40, family: 'Helvetica'}).move(20, currentHeightOffset);
            currentHeightOffset += 60;

            // not null
            currentWidthOffset += drawIcon("muscle", "Damage", action.attack.damage, currentWidthOffset, currentHeightOffset);
            currentWidthOffset += drawIcon("bow", "Range", action.attack.range, currentWidthOffset, currentHeightOffset);

            let hasArea = action.attack.area != null && action.attack.area != "1" && action.attack.area != "0";
            let hasNumber = action.attack.numberOfAttacks != null && action.attack.numberOfAttacks != "1";

            if (hasArea || hasNumber) {
                currentHeightOffset += 80;
                currentWidthOffset = 20;
            }
            currentWidthOffset += drawIcon("person", "Target", action.attack.target, currentWidthOffset, currentHeightOffset);

            // nullable

            if (hasArea || hasNumber) {
                if (hasArea) {
                    currentWidthOffset += drawIcon("arrow", "Area", action.attack.area, currentWidthOffset, currentHeightOffset);
                }
                if (hasNumber) {
                    currentWidthOffset += drawIcon("hash", "Count", action.attack.numberOfAttacks, currentWidthOffset, currentHeightOffset);
                }
            }

            currentHeightOffset += drawEffects(action.attack.effects, currentHeightOffset);

            currentHeightOffset += 100;
        }

        // skill
        if (action.skill != null) {
            let currentWidthOffset = 20;
            draw.text("Skill").font({fill: black, size: 40, family: 'Helvetica'}).move(20, currentHeightOffset);
            currentHeightOffset += 60;

            // not null
            currentWidthOffset += drawIcon("bow", "Range", action.skill.range, currentWidthOffset, currentHeightOffset);
            currentWidthOffset += drawIcon("person", "Target", action.skill.target, currentWidthOffset, currentHeightOffset);

            // nullable
            if (action.skill.area != null && action.skill.area != "1" && action.skill.area != "0") {
                currentWidthOffset += drawIcon("arrow", "Area", action.skill.area, currentWidthOffset, currentHeightOffset);
            }

            currentHeightOffset += drawEffects(action.skill.effects, currentHeightOffset);

            currentHeightOffset += 100;
        }

        // restoreCards
        if (action.restoreCards != null) {
            let currentWidthOffset = 20;
            draw.text("Restore Cards").font({fill: black, size: 40, family: 'Helvetica'}).move(20, currentHeightOffset);
            currentHeightOffset += 60;

            // not null
            currentWidthOffset += drawIcon("hash", "Count", action.restoreCards.numCards, currentWidthOffset, currentHeightOffset);
            currentWidthOffset += drawIcon("person", "Target", action.restoreCards.target, currentWidthOffset, currentHeightOffset);

            // nullable
            if (action.restoreCards.random === true) {
                currentWidthOffset += drawIcon("random", "Random", action.restoreCards.random, currentWidthOffset, currentHeightOffset);
            }

            currentHeightOffset += 100;
        }

        // discard at right bottom corner
        if (action.discard !== "NEVER") {
            let discardBorder = draw.rect(170, 50).radius(20).attr({fill: black}).move(width - 170, height - 50);
            let discardBackground = draw.rect(165, 44).radius(18).attr({fill: lightColor}).move(width - 167.5, height - 47.5);
            let discardText = draw.text("Discard").font({fill: black, size: 30, family: 'Helvetica'}).move(width - 137, height - 40);
        }

        const svg = document.getElementById("card").firstChild;

        // Convert each image to base64
        const images = svg.querySelectorAll("image");
        for (let i = 0; i < images.length; i++) {
            const image = images[i];
            const url = image.getAttribute("href");
            const response = await fetch(url);
            const blob = await response.blob();
            const reader = new FileReader();
            reader.onload = function () {
                image.setAttribute("href", reader.result);
            };
            reader.readAsDataURL(blob);
        }

        // Wait for all images to be converted
        await new Promise(resolve => setTimeout(resolve, 250));
        Notiflix.Block.remove("#loading");
    }

    generateCard({{ actionId }});
</script>